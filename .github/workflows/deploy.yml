name: Deploy with Helm

on:
  workflow_run:
    workflows: ["Docker Release"]
    types:
      - completed
    branches: [ main ]
  # Add manual trigger capability
  workflow_dispatch:
    inputs:
      environment:
        description: 'Environment to deploy to'
        required: true
        default: 'production'
        type: choice
        options:
          - production
          - staging
          - development
      namespace:
        description: 'Kubernetes namespace to deploy to'
        required: false
        default: 'default'
        type: string

# Add permissions for GITHUB_TOKEN
permissions:
  contents: read
  packages: read

jobs:
  # Check if required secrets exist before proceeding
  check-secrets:
    runs-on: ubuntu-latest
    outputs:
      secrets-exist: ${{ steps.check-secrets.outputs.defined }}
    steps:
      - name: Check if secrets exist
        id: check-secrets
        run: |
          # Check if required secrets exist
          if [ -n "$HELM_VALUES" ] && ([ -n "$KUBE_CONFIG" ] || [ -n "$DO_TOKEN" ]); then
            echo "defined=true" >> $GITHUB_OUTPUT
          else
            echo "defined=false" >> $GITHUB_OUTPUT
            echo "::error::Required secrets are not set. You need HELM_VALUES_YAML and either KUBE_CONFIG or DIGITALOCEAN_ACCESS_TOKEN."
          fi
        shell: bash
        env:
          # Pass secrets as environment variables
          KUBE_CONFIG: ${{ secrets.KUBE_CONFIG }}
          DO_TOKEN: ${{ secrets.DIGITALOCEAN_ACCESS_TOKEN }}
          HELM_VALUES: ${{ secrets.HELM_VALUES_YAML }}

  deploy:
    needs: check-secrets
    # Only run if secrets exist and (workflow was manually triggered or workflow was successful AND from main branch)
    if: |
      needs.check-secrets.outputs.secrets-exist == 'true' && 
      (github.event_name == 'workflow_dispatch' || 
       (github.event.workflow_run.conclusion == 'success' && github.event.workflow_run.head_branch == 'main'))
    runs-on: ubuntu-latest
    # Set environment to enable protection rules if needed
    environment: ${{ github.event.inputs.environment || 'production' }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        
      - name: Set up Helm
        uses: azure/setup-helm@v3
        with:
          version: 'latest'
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          
      - name: Check for DigitalOcean token
        id: check-do-token
        run: |
          if [ -n "$DO_TOKEN" ]; then
            echo "has_token=true" >> $GITHUB_OUTPUT
          else
            echo "has_token=false" >> $GITHUB_OUTPUT
          fi
        env:
          DO_TOKEN: ${{ secrets.DIGITALOCEAN_ACCESS_TOKEN }}

      - name: Install doctl
        if: steps.check-do-token.outputs.has_token == 'true'
        id: install-doctl
        uses: digitalocean/action-doctl@v2
        with:
          token: ${{ secrets.DIGITALOCEAN_ACCESS_TOKEN }}
          
      - name: Verify doctl authentication
        if: steps.check-do-token.outputs.has_token == 'true'
        id: verify-doctl
        run: |
          echo "Verifying DigitalOcean authentication..."
          # Use kubernetes command since the token has kubernetes permissions
          doctl kubernetes options regions
          if [ $? -ne 0 ]; then
            echo "::error::Failed to authenticate with DigitalOcean. Please check your access token."
            echo "doctl_auth_success=false" >> $GITHUB_OUTPUT
            exit 1
          else
            echo "DigitalOcean authentication successful."
            echo "doctl_auth_success=true" >> $GITHUB_OUTPUT
          fi
          
      - name: Check for KUBE_CONFIG
        id: check-kube-config
        run: |
          if [ -n "$KUBE_CONFIG" ]; then
            echo "has_config=true" >> $GITHUB_OUTPUT
          else
            echo "has_config=false" >> $GITHUB_OUTPUT
          fi
        env:
          KUBE_CONFIG: ${{ secrets.KUBE_CONFIG }}
          
      - name: Set up kubeconfig
        if: (steps.check-do-token.outputs.has_token == 'true' && steps.verify-doctl.outputs.doctl_auth_success == 'true') || steps.check-kube-config.outputs.has_config == 'true'
        env:
          DO_TOKEN: ${{ secrets.DIGITALOCEAN_ACCESS_TOKEN }}
          DO_CLUSTER_ID: ${{ secrets.DIGITALOCEAN_CLUSTER_ID }}
          KUBE_CONFIG: ${{ secrets.KUBE_CONFIG }}
        run: |
          set +x  # Disable command echoing
          umask 077  # Set strict permissions
          mkdir -p $HOME/.kube
          
          # Check if we have DigitalOcean credentials
          if [ -n "$DO_TOKEN" ]; then
            echo "Using DigitalOcean credentials to access Kubernetes cluster"
            
            # List all clusters
            echo "Listing all available clusters:"
            CLUSTERS_JSON=$(doctl kubernetes cluster list --output json)
            if [ $? -ne 0 ]; then
              echo "::error::Failed to list Kubernetes clusters. Check token permissions."
              exit 1
            fi
            
            # Check if we have any clusters
            CLUSTER_COUNT=$(echo "$CLUSTERS_JSON" | jq length)
            if [ "$CLUSTER_COUNT" -eq 0 ]; then
              echo "::error::No Kubernetes clusters found in your DigitalOcean account"
              exit 1
            fi
            
            # Try to use the provided cluster ID if available
            if [ -n "$DO_CLUSTER_ID" ]; then
              echo "Attempting to use provided cluster ID"
              if doctl kubernetes cluster kubeconfig save "$DO_CLUSTER_ID" 2>/dev/null; then
                echo "Successfully saved kubeconfig using provided cluster ID"
              else
                echo "Could not find cluster with provided ID, falling back to first available cluster"
                # Get the ID of the first cluster
                FIRST_CLUSTER_ID=$(echo "$CLUSTERS_JSON" | jq -r '.[0].id')
                echo "Using first available cluster with ID: $FIRST_CLUSTER_ID"
                if doctl kubernetes cluster kubeconfig save "$FIRST_CLUSTER_ID"; then
                  echo "Successfully saved kubeconfig using first available cluster"
                else
                  echo "::error::Failed to save kubeconfig for any cluster"
                  exit 1
                fi
              fi
            else
              # No cluster ID provided, use the first available cluster
              FIRST_CLUSTER_ID=$(echo "$CLUSTERS_JSON" | jq -r '.[0].id')
              echo "No cluster ID provided. Using first available cluster with ID: $FIRST_CLUSTER_ID"
              if doctl kubernetes cluster kubeconfig save "$FIRST_CLUSTER_ID"; then
                echo "Successfully saved kubeconfig using first available cluster"
              else
                echo "::error::Failed to save kubeconfig for first available cluster"
                exit 1
              fi
            fi
          # Otherwise use provided kubeconfig
          elif [ -n "$KUBE_CONFIG" ]; then
            echo "Using provided kubeconfig"
            # Process in memory without echoing to pipes when possible
            if [[ "$KUBE_CONFIG" == *"apiVersion:"* ]]; then
              # Plain text config
              echo "$KUBE_CONFIG" > $HOME/.kube/config
            else
              # Likely base64 encoded
              echo "$KUBE_CONFIG" > $HOME/.kube/config.b64
              base64 -d $HOME/.kube/config.b64 > $HOME/.kube/config 2>/dev/null || cat $HOME/.kube/config.b64 > $HOME/.kube/config
              rm -f $HOME/.kube/config.b64
            fi
          fi
          
          # Ensure config exists before setting permissions
          if [ -f "$HOME/.kube/config" ]; then
            chmod 600 $HOME/.kube/config
          else
            echo "::error::Failed to create kubeconfig file"
            exit 1
          fi
        shell: bash
          
      - name: Create values.yaml from secret
        run: |
          set +x  # Disable command echoing
          umask 077  # Set strict permissions
          # Write directly to file to avoid heredoc issues
          HELM_VALUES="${{ secrets.HELM_VALUES_YAML }}"
          echo "$HELM_VALUES" > ./helm/values.yaml
          chmod 600 ./helm/values.yaml
          # Verify file was created successfully
          if [ ! -s "./helm/values.yaml" ]; then
            echo "::error::Failed to create values.yaml file"
            exit 1
          fi
        shell: bash
          
      - name: Deploy with Helm
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          set +x  # Disable command echoing
          # Verify kubeconfig and values.yaml exist before deployment
          if [ ! -f "$HOME/.kube/config" ] || [ ! -s "./helm/values.yaml" ]; then
            echo "::error::Missing required configuration files"
            exit 1
          fi
          
          # Sanitize namespace input
          NAMESPACE="${{ github.event.inputs.namespace || 'default' }}"
          NAMESPACE="${NAMESPACE//[^a-zA-Z0-9-]/-}"
          
          cd helm
          
          helm upgrade --install qelos-release qelos \
            -f values.yaml \
            --namespace "$NAMESPACE" \
            --create-namespace \
            --atomic \
            --timeout 10m \
            --debug=false \
            --history-max 10
          
          # Don't show detailed error output that might contain secrets
          if [ $? -ne 0 ]; then
            echo "::error::Helm deployment failed"
            exit 1
          fi
        shell: bash
